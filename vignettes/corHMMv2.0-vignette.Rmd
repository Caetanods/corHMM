---
title: "corHMMv2.0-Vignette"
author: "James D. Boyko"
date: '2020-02-11'
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{corHMMv2.0-Vignette}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(fig.width=6, fig.height=8)
```

# corHMMv2.0 Vignette

corHMM is an R-package for creating and optimizing Markov models and hidden Markov models. These models describe evolution as discrete transitions between observed states. Although not discussed in this vignette, corHMM also does ancestral state reconstruction (see details of ancRECON function for more). We choose to focus on model creation rather than ancestral state reconstruction because ASR is exactly correlated with your model. If you choose an unrealistic model of trait evolution, your ancestral state reconstruction is equally unrealistic. Choosing a model specific to your question is of utmost importance in any comparative method, and in corHMMv2.0 we provide users with the tools to create their own hidden Markov models.

This vignette is composed of three sections: 

* __Section 1 demonstrates the default use of corHMMv2.0__
    * 1.1: No hidden rate categores
    * 1.2: Any number of hidden rate categories

* __Section 2 demonstrates how to make and interpret custom models__
    * 2.1: Creating and using custom rate matrices
        * 2.1.1: One rate category
        * 2.1.2: Any number of rate categories
    * 2.2: Some examples of "biologically informed" models
        * 2.2.1: Precursor model
        * 2.2.2: Ordered habitat change
        * 2.2.3: Ontological relationship of multiple characters
    * 2.3: Estimating models when node states are fixed

* __Section 3 uses various tests to demonstrate that corHMM is working as intended__
    * 3.1: rayDISC-_like_ models in corHMM
    * 3.2: corHMM works for n States
    * 3.3: corHMMv2.0 is the same as previous versions

# Section 1: default use of corHMM

## 1.1: No hidden rate categories

We'll use the primate dataset that comes with corHMM.

```{r, message=FALSE, warning=FALSE}
set.seed(1985)
require(ape)
require(expm)
require(corHMM)
data(primates)
phy <- primates[[1]]
phy <- multi2di(phy)
data <- primates[[2]]
```

```{r, fig.align="center", fig.width=6, fig.height=6}
plot(phy, show.tip.label = FALSE)
tiplabels(pch = 16, col = data[,2]+1, cex = 0.5)
tiplabels(pch = 16, col = data[,3]+3, cex = 0.5, offset = 0.5)
```

We have two characters each with two possible states. Trait 1 could either be having a tail (red) or not having a tail (black). And trait 2 could be the presence of sexual dimorphism (blue) or the absence of sexual dimorphism (green). 

The default use of corHMM only requires that you declare your *phylogeny*, your *dataset*, the number of *rate categories* (more detail about this later). Data must be categorical and the states must be mutually exclusive.

We have updated corHMMv2.0 to handle different types of input data. Previously, the data could only contain two columns: [,1] a column of species names, and [,2] a column of state values. As of corHMMv2.0, the first column must be species names (as in the previous version), but there can be as many other columns as the user would like. Each of these data columns must still be categorical.

```{r}
MK_3state <- corHMM(phy = phy, data = data, rate.cat = 1)
```

By default, a marginal ancestral state reconstruction will be preformed.

```{r}
MK_3state
```

When you run your corHMM object you are greeted with a summary of the model. Your model fit is described by the negative log likelihood (-lnL), Akaike information criterion (AIC), and sample size corrected Akaike information criterion (AICc). You are also given the number of rate categories (Rate.cat) and number of taxa (ntax). Below *Fit* is the real meat of the model: *Rates*.

The rates describe transitions between states and are organized as a matrix. This *transition rate matrix* can be read as describing the transition rate **from** ROW **to** COLUMN. For example, if you were interested in the transition rate from State 1 (sexually dimorphic with tails) to State 3 (no sexual dimorphism and no tails) you would be looking at the number in the upper right corner. For a time calibrated ultrametric tree, these rates will depend on the age of your phylogeny. So a rate of 0.1 for a tree that is 10 Million Years old represents one transition from state A to state B every 100,000,000 years. 

Interpreting a Markov matrix can be difficult, especially when you're just starting out. This problem is compounded when users begin to use the more complex Hidden Markov models (which is done by setting rate.cat > 1). To help users we have implemented a new plotting function which will hopefully make it much simpler to understand these models.

```{r, fig.align="center", fig.width=6, fig.height=4}
plotMKmodel(MK_3state)
```

This function can take a corHMM object (which is the result of running corHMM) and plot the model in two parts. On the left is a ball and stick diagram depicting the transitions between the states. On the right is a simplified rate matrix (a rounded version of the solution output of corHMM). The colors of the arrows match the rates.

corHMM automatically converts multi-column data, like we provided, into a single column of unique combinations. To help users interpret this transformation, we now provide a data legend.

```{r}
head(MK_3state$data.legend)
```

This takes the user input data table and adds a new column that corresponds to the corHMM state of that row's trait combination. The 3 possible combinations in this case are having a tail and being sexually dimorphic (state 1), not having a tail and being sexually dimorphic (state 2), or not having a tail and not being sexually dimorphic (state 3). These are the states that will be used for all corHMM outputs.

#### 1.2: A trait with any number of states and any number of hidden rate categories

The major difference between corHMMv2.0 and previous versions is allowing models of any number of states and any number of hidden rate categories (*hidden rate categories will be explained in more depth in section 2*). Running a hidden Markov model (HMM) is as easy as assigning a value greater than 1 to the rate.cat input. We will use the 3-state data from above and assign 2 rate categories. 

```{r}
HMM_3state <- corHMM(phy = phy, data = data, rate.cat = 2, model = "SYM")
```

Models with more states take longer to run. Hidden rate models are no exception, and we have increased the number of parameters being estimated from 6 (in a 3-state one rate category Markov model) to 14 by adding a hidden rate category. In section 1.1 we left our parameters unconstrained. We estimated all transisions as independent and allowed for transitions from all states to any other state. However, we can constrain a model in corHMM in two different ways. The easiest way is to set the model to either "SYM" or "ER". This is what we've done for the HMM_3state model above. By setting model = "SYM" we have said that the transition rates between two states are equal. Although this type of restriction is common, it is often more useful to manually restrict your model (which is described in the next section).

```{r}
round(HMM_3state$solution,3)
```

Looking at the solution of this hidden Markov model is intimidating, but the same principles of interpreting the transition rate matrices apply. You still read rates from row to column. However, we have added different rate categories (as represented by R1 and R2. Each rate category contains the same model we had in section 1.1. That is to say, (0,R1),(1,R1), and (2,R1) are a Markov model of transitions between states 1, 2, and 3. If you're confused, don't worry. This becomes much easier to interpret once you've learned how to design and build your own HMM.

# Section 2: custom corHMM models

## 2.1: Creating and using custom rate matrices

### 2.1.1: One rate category

A rate matrix is the best way for you to communicate your model to corHMM because it allows you to specify how traits are expected to evolve. If you believe that traits evolve in a certain order, that there are different rates of character evolution in different clades, or that there are hidden precursors before a state can evolve, then a custom model is the best way to specify your particular hypothesis.

At its core, the purpose of a rate matrix (rate.mat) is to indicate to corHMM which parameters are being estimated. A rate.mat does not actually contain *rates*. It would more appropriately named an index matrix because it specifies to corHMM which rates in the matrix are being estimated and if any of them are expected to be identical.

Let's start by examining a simple rate.mat: 3 states and 1 rate category. 

```{r}
StateMatA <- getStateMat(nState = 3)
StateMatA
```

This is the rate.mat that was internally called when we ran our model in section 1.1. The numbers in this matrix are not rates, they are used to index the parameters within corHMM. Each distinct number is a parameter to be estimated independently from all others. Let's manually create the symmetric model we used in secion 1.2. We want transitions *to* a state to be the same as *from* that state. 


```{r}
pars2equal <- list(c(1,3), c(2,5), c(4,6))
StateMatA_constrained <- equateStateMatPars(StateMatA, pars2equal)
StateMatA_constrained
```

We used equateStateMatPars whose first argument is *the rate matrix being modified* and second argument is *list of the parameters to be equated* to recreate the "SYM" model. 

```{r}
pars2equal
```

You should make sure that you have the appropriate number of rate categories. A user rate matrix will not be duplicated or changed by corHMM to a correct number of rate categories. Rather, corHMM will output an error. This custom model can only be used if the appropriate number of rate categories is indicated. We can now give this rate.mat to corHMM, and it will estimate this constrained model.

```{r}
MK_3state_customSYM <- corHMM(phy = phy, data = data, rate.cat = 1, rate.mat = StateMatA_constrained)
round(MK_3state_customSYM$solution, 3)
```

As you can see, transitions between, from, and to states are equal, as we had hoped.

### 2.1.2: Any number of rate categories

If you wanted to add hidden rate categories you need to know 2 things: 

First, you need to know the dynamics within each rate category. StateMatA could describe the dynamics within Rate Category 1, StateMatA_constrained could be the dynamics within Rate Category 2.

```{r}
StateMatA # rate category 1
StateMatA_constrained # rate category 2
```

Second, you need to know how these rate categories relate to one another. Do transitions from R1 to R2 occur at the same rate as R2 to R1? If we had a 3rd rate category, could it represent an intermediate stage (such that R1 -> R3 -> R2)? These types of questions are codified when declaring how your rate categories are related to one another. This means that the RateClassMat will have as many states as there are rate categories.

The easiest scenario to implement is one where the transitions between R1 and R2 independent. But, for this example, we'll say that transitions from R1 to R2 is the same as R2 to R1. 

```{r}
RateClassMat <- getStateMat(2) # the size of this state matrix is the no. of rate classes
RateClassMat
RateClassMat_constrained <- equateStateMatPars(RateClassMat, c(1,2))
RateClassMat_constrained
```

Once we have all of the individual components of our model, we put it all together with getFullMat. getFullmat requires that the first input be a list of the rate class matrices and the second argument be how they are related to one another.

```{r}
StateMats <- list(StateMatA, StateMatA_constrained)
```

We've already created the matrix that defines how the StateMats are related to one another.

```{r}
RateClassMat_constrained
```

Now we can combine them.

```{r}
FullMat <- getFullMat(StateMats, RateClassMat_constrained)
FullMat
```

Even though we created this larger index matrix from its individuals components we may not be sure it's exactly what we want. We can use plotMKmodel to also plot an index matrix. This makes it easy to make sure the custom you model you created is the one you want. 

```{r, fig.align = "center", fig.width=10, fig.height=3}
plotMKmodel(pp = FullMat, rate.cat = 2, display = "row", text.scale = 0.7)
```

The first two plots are transitions between our observed states 1,2,3. If we focus just on those we can see the same general model structure that was present in section 1.1. As we intended, the dynamics of R1 differ from R2. R1 is a completely unconstrained model, whereas for R2, the rates between two states are the same regardless of which state the lineage is changing from or to. The 3rd and final plot (Rate Category Transition matrix) describes how species transition between R1 and R2. 

Since this is the model we intended on making, we can run corHMM with our custom matrix.

```{r}
HMM_3state_custom <- corHMM(phy = phy, data = data, rate.cat = 2, rate.mat = FullMat, node.states = "none")
round(HMM_3state_custom$solution, 3)
```

And now we can plot the HMM with rates instead of indices. 

```{r, fig.width=10, fig.height=3}
plotMKmodel(HMM_3state_custom, display = "row", text.scale = 0.7)
```

## 2.2: Some examples of "biologically informed" models

### 2.2.1: The precursor model

The precursor from Marazzi et al. (2012) is a good example to start with. They were interested in locating putative evolutionary precursors of plant extrafloral nectaries (EFNs). There are 2 states, absence (0) and presence (1) of extrafloral nectaries. However, they proposed that only species with a precursor could gain EFNs. Unfortunately, this precursor is not observed. Here is how we could code this rate matrix in corHMM.

```{r}
StateMat_Precur <- getStateMat(2)
StateMat_Precur
```

If the precursor is not present then they cannot evolve the presence of extrafloral nectaries. We use the function dropStateMatPars.

```{r}
StateMat_noPrecur <- dropStateMatPars(StateMat_Precur, 2)
StateMat_noPrecur
```

Let's put these state matrices in a list and update them.

```{r}
StateMats_precur <- list(StateMat_noPrecur, StateMat_Precur)
```

We'll say that the precursor's rate of gain is the different from its rate of loss.

```{r}
RateClassMat_precur <- getStateMat(2)
```

We put it all together now.

```{r}
FullMat_precur <- getFullMat(StateMats_precur, RateClassMat_precur)
FullMat_precur
```

Plot the model to make sure it's what we wanted.

```{r, fig.align="center", fig.width=10, fig.height=4}
plotMKmodel(FullMat_precur, 2, display = "row", text.scale = 0.7)
```

We'll apply this to only one the first column of our primate dataset.

```{r}
res_precur_corHMM <- corHMM(phy = phy, data = data[,c(1,2)], rate.cat = 2, rate.mat = FullMat_precur)
res_precur_corHMM
```

```{r, fig.align="center", fig.width=10, fig.height=4}
plotMKmodel(res_precur_corHMM, display = "row", text.scale = 0.7)
```

In addition to plotting this model, let's look at each entry (row #, col #) and interpret the biological meaning.

```{r}
round(res_precur_corHMM$solution, 3)
```

* Entry (2,1) is the rate of loss of extrafloral nectaries when the precursor is absent.
* Entries (3,1) and (4,1) are the rates at which the precursor is lost.
* Entries (1,3) and (1,4) are the rates at which the precursor is gained (remember we constrained that the rate of gain and loss were the same, hence the parameter estimates being the same).
* Entry (3,4) is the rate of gain of extrafloral nectaries when the precursor is present.
* Entry (4,3) is the rate of loss of extrafloral nectaries when the precursor is present.

### 2.2.2: Ordered habitat change

I'm working on a project concerned with the ancestral habitat during primary endosymbiosis. The possible habitats are marine, freshwater, and terrestrial. The phylogeny contains many species with a diverse range of life histories. Cyanobacteria can move freely between all of these states. But, some species may move between terrestrial and marine through freshwater. Finally, some species may move freely between aquatic states, but once they become terrestrial they are stuck there. In this section I will demonstrate how to create a custom hidden Markov model which satisfies all of these requirements. First I'm going to need 3 state matrices.

```{r}
StateMat_FreeMoving <- getStateMat(3)
StateMat_InterFresh <- getStateMat(3)
StateMat_TerraStuck <- getStateMat(3)
```

We will need to constrain these matrices in unique ways to get what we want. The free-moving matrix is already done. So let's move onto freshwater as an intermediate state.

```{r}
StateMat_FreeMoving
```

We need to disallow transitions between terrestrial and marine. Let's say the dataset has 1 = marine, 2 = freshwater, and 3 = terrestrial. We disallow the positions (1,3) and (3,1) in the rate matrix.

```{r}
StateMat_InterFresh <- dropStateMatPars(StateMat_InterFresh, c(2,5))
StateMat_InterFresh
```

That looks good, so let's work on terrestrial as a sink state. Same starting point, but now we disallow transitions out of terrestrial. That means removing positions (3,1) and (3,2).

```{r}
StateMat_TerraStuck <- dropStateMatPars(StateMat_TerraStuck, c(2,4))
StateMat_TerraStuck
```
Let's put all these matrices in a list and update them.

```{r}
StateMats_MFT <- list(StateMat_FreeMoving, StateMat_InterFresh, StateMat_TerraStuck)
```

Let's say that species transition between the rate categories at the same rate.

```{r}
RateClassMat_MFT <- getStateMat(3)
RateClassMat_MFT_constrained <- equateStateMatPars(RateClassMat_MFT, 1:6)
```

And we put it all together into a corHMM compatible rate.mat.

```{r}
FullMat_MFT <- getFullMat(StateMats_MFT, RateClassMat_MFT_constrained)
FullMat_MFT
```

That's kind of difficult to interpret, so let's plot it out and see if it's what we wanted.

```{r, fig.align = "center", fig.height=8, fig.width=8}
plotMKmodel(pp = FullMat_MFT, rate.cat = 3, display = "square", text.scale = 0.9)
```

And it is. To run this model, we would only need to specify the data, the phylogeny, this matrix, and that this matrix has 3 rate categories.

<!-- We will simulate 3 state data. And don't forget to set rate categories to the appropriate number. -->

<!-- ```{r} -->
<!-- Q <- abs(matrix(rnorm(9, 0.75, 0.25),3,3)) -->
<!-- diag(Q) <- 0 -->
<!-- diag(Q) <- -rowSums(Q) -->
<!-- dat <- sim.char(phy, Q, 1, "discrete") -->
<!-- data <- data.frame(sp = phy$tip.label, d = dat[,,1]) -->
<!-- res_MFT <- corHMM(phy = phy, data = data, rate.cat = 3, rate.mat = FullMat_MFT) -->
<!-- res_MFT -->
<!-- ``` -->

<!-- ```{r} -->
<!-- plotMKmodel(res_MFT) -->
<!-- ``` -->

### 2.2.3: Ontological relationship of multiple characters

Lets say we had a dataset with multiple characters: presence or absence of limbs, presence or absence of fingers, corporeal or incorporeal form. It could look something like this...

```{r}
Limbs <- c("Limbs", "noLimbs")[data[,2]+1]
Fings <- vector("numeric", length(phy$tip.label))
Fings[which(Limbs == "Limbs")] <- round(runif(length(which(Limbs == "Limbs")), 0, 1))
Corpo <- rep("corporeal", length(phy$tip.label))
OntData <- data.frame(sp = phy$tip.label, limbs = Limbs, fings = Fings, corp = Corpo)
head(OntData)
```

Previously, the user would have had to convert this dataset into something corHMM could use. This would mean taking all possible unique combinations and creating a corHMM specific dataset. Now, corHMM will internally convert this dataset and provide users with a legend in the results section for aiding the interpretation of the results.

But, if we want to create a custom model, it would be useful to know beforehand how corHMM is going to organize our data. To do this, we use the function getRateMat4Dat

```{r}
LegendAndMat <- getRateMat4Dat(OntData, phy)
LegendAndMat
```

corHMM found 3 different trait combinations. However, this matrix seems off. It doesn't make sense that an organism can transition from having *no limbs & no fingers (1,R1)* to *limbs & fingers (2,R1)*. *limbs & no fingers (3,R1)* is an intermediate stage. Rather than creating a matrix from scratch, I'll just modify the one produced by getRateMat4Dat.

```{r}
OntRateMat <- LegendAndMat$rate.mat
OntRateMat_constr <- dropStateMatPars(OntRateMat, c(1,3))
OntRateMat_constr
```

This rate matrix now constrains lineages that transition between *no limbs & no fingers* and *limbs & fingers* must go through a state of *limbs & no fingers*. 

```{r}
ontRes <- corHMM(phy = phy, data = OntData, rate.cat = 1, rate.mat = OntRateMat_constr)
```

```{r, fig.align="center", fig.width=6, fig.height=4}
plotMKmodel(ontRes, display = "column")
```


## 2.3: Estimating models when node states are fixed

Jeremy's code goes here.

<!-- #Section 3: unit tests of corHMM -->
<!-- ##3.1: rayDISC-_like_ models in corHMM -->

<!-- rayDISC is a function that runs Markov models where all states are observed. I have implemented this functionality within corHMM so that users only need to use one function when working with corHMM. Let's simulate a fresh 3-state dataset. -->

<!-- ```{r} -->
<!-- phy <- sim.bdtree(b = 1, d = 0.8, n = 100, stop = "taxa", extinct = FALSE) -->
<!-- phy <- drop.extinct(phy) -->
<!-- mean.change <- 1/sum(phy$edge.length)*20 -->

<!-- Q <- matrix(abs(rnorm(9, mean.change, mean.change/2)), 3, 3) -->
<!-- diag(Q) <- 0 -->
<!-- diag(Q) <- -rowSums(Q) -->

<!-- dat <- sim.char(phy, Q, 1, "discrete") -->
<!-- dat <- dat[,,1] -->
<!-- data <- data.frame(sp = names(dat), dat = dat) -->
<!-- ``` -->

<!-- We can run rayDISC easily.  -->

<!-- ```{r} -->
<!-- rayRes <- rayDISC(phy = phy, data = data, model = "ARD", root.p = "flat") -->
<!-- ``` -->

<!-- I will take the parameters from rayDISC and use corHMM to evaluate their likelihood. If all goes well the likelihood for these parameters will be the same in rayDISC and corHMM. -->

<!-- ```{r} -->
<!-- data.sort <- data.frame(data[,2], data[,2],row.names=data[,1]) -->
<!-- data.sort <- data.sort[phy$tip.label,] -->
<!-- model.set.final <- corHMM:::rate.cat.set.corHMM.JDB(phy=phy,data.sort=data.sort,rate.cat=1,ntraits=3, model = "ARD") -->
<!-- p = c(na.omit(as.vector(rayRes$solution))) -->
<!-- corRes <- corHMM(phy = phy, data = data, rate.cat = 1, rate.mat = model.set.final$rate, p = p, root.p = "flat") -->
<!-- c(rayRes$loglik, corRes$loglik) -->
<!-- rayRes$loglik == corRes$loglik -->
<!-- ``` -->

<!-- ##3.2: corHMM works for n States -->

<!-- To test that corHMM is working for multiple states and hidden rates we need to construct a pseudo-hidden rate model. This pseudo hidden rate model will be evaluated as any rate.cat > 1 model is, but it will have the same likelihood as a model that could be run in rayDISC. The key is distributing those parameters within corHMM such that we don't expect a different likelihood.  -->

<!-- ```{r} -->
<!-- data.sort <- data.frame(data[,2], data[,2],row.names=data[,1]) -->
<!-- data.sort <- data.sort[phy$tip.label,] -->
<!-- model.set.final<- corHMM:::rate.cat.set.corHMM.JDB(phy=phy,data.sort=data.sort,rate.cat=2,ntraits=3,model ="ARD") -->
<!-- model.set.final$index.matrix -->
<!-- ``` -->

<!-- This is our 2 rate class model. However, we will assign the same parameters to R1 and R2. There should be no difference in likelihood between this model and rayDISC - *we can use the rayDISC result from section 3.1.*. -->

<!-- ```{r} -->
<!-- p = c(na.omit(as.vector(rayRes$solution)), na.omit(as.vector(rayRes$solution)), 1,1,0) -->
<!-- corRes_2rate <- corHMM(phy = phy, data = data, rate.cat = 2, mV = TRUE, rate.mat = model.set.final$rate, p = p, root.p = "flat") -->
<!-- c(corRes_2rate$loglik, rayRes$loglik) -->
<!-- ``` -->

<!-- ##3.3: corHMMv2.0 is the same as previous versions -->

<!-- For this section I've run some models in the previous version of corHMM. I am going to use those corhmm objects to demonstrate that new corHMM and old corHMM exist in harmony. -->

<!-- Is old rayDISC the same as new rayDISC? -->

<!-- ```{r} -->
<!-- load("~/Desktop/oldCorRes.Rsave") -->
<!-- p <- na.omit(as.vector(obj$def.rayDISC$solution)) -->
<!-- newRay <- rayDISC(phy = obj$def.rayDISC$phy, data = obj$def.rayDISC$data, model = "ARD", ntraits = 1, p = p, rate.mat = obj$def.rayDISC$index.mat, root.p = "flat") -->
<!-- newRay$loglik == obj$def.rayDISC$loglik -->
<!-- ``` -->

<!-- Is old corHMM the same as new corHMM? -->

<!-- ```{r} -->
<!-- p <- na.omit(as.vector(obj$def.corHMM$solution)) -->
<!-- data <- data.frame(sp = rownames(obj$def.corHMM$data), dat = obj$def.corHMM$data[,1]) -->
<!-- newCor <- corHMM(phy = obj$def.corHMM$phy, data = data, rate.cat = 2, rate.mat = obj$def.corHMM$index.mat, p = p) -->
<!-- obj$def.corHMM$loglik == newCor$loglik -->
<!-- ``` -->

<!-- Is old corHMM the same as new corHMM when the model is constrained? -->

<!-- ```{r} -->
<!-- p <- na.omit(as.vector(obj$const.corHMM$solution)) -->
<!-- p <- p[c(-4, -7)] -->
<!-- data <- data.frame(sp = rownames(obj$const.corHMM$data), dat = obj$const.corHMM$data[,1]) -->
<!-- newCor <- corHMM(phy = obj$const.corHMM$phy, data = data, rate.cat = 2, rate.mat = obj$const.corHMM$index.mat, p = p) -->
<!-- obj$const.corHMM$loglik == newCor$loglik -->
<!-- ``` -->
